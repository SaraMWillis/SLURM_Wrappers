#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''
Author : Sara Willis, University of Arizona
Date   : October 18, 2021
Update : March 2022, lots of changes!
    - Fixed GPU overcounting
    - Added user specifications 
    - Automated process of collecting valid partition names
    - Split Display subroutine into multiple subroutines
    - Auto-cluster node types based on user options

This script is designed to print a visualization of a SLURM cluster's resource usage.

This script has been tested on:
    - University of Arizona's HPC systems
    - Bridges2

'''

import subprocess, sys, os, random, datetime, getopt, math, re


'''
------------------------------------------------------------------------------------------
##########################################################################################
                                    User Options                                
##########################################################################################
------------------------------------------------------------------------------------------


                                    User Specifications

'''

# Another possible option. Add annotations next to a specific node type. E.g., UArizona's
# system adds an annotation for buy-in nodes. 
# The format for this should be a dictionary with:
# {AnnotationDescription: "Ascii Symbol": "symbol here", "UTF-8 Symbol": "symbol here", "Field": "scontrol field", "Value": "field value", "Message": "display message at bottom of output"}
# This will annotate specific nodes with something like (assuming ascii symbol = **):

# NodeName1 [####   ] x% **
# NodeName2 [####   ] x%
# ...
# ** Node annotation
# 
# If annotations are not desired, set node_annotations = None
global node_annotations
node_annotations = {"HiPri": {"Ascii Symbol":"*","UTF-8 Symbol":u'\u271A',"Field":"Partitions","Value":"windfall,high_priority","Message":"Buy-in nodes. Only accept high_priority and windfall jobs"},
                    "Test": {"Ascii Symbol":"+","UTF-8 Symbol":u'\u25A3', "Field": "Gres","Value": "gpu:kepler:1", "Message":"This is a test"}
                    }

# Trying a more systematic way of specifying node types.
# Priority is used to help with grouping.
global node_types
node_types = {"Standard Nodes"    : {"Name" :"Standard Nodes", "Field": None, "Value":None,"Priority":1},
              "Buy-In Nodes"      : {"Name": "Buy-In Nodes","Field":"Partitions", "Value":"windfall,high_priority","Priority":4},
              "GPU Nodes"         : {"Name": "GPU Nodes","Field":["AllocTRES","CfgTRES"],"Value":"gpu","Priority":2},
              "High Memory Nodes" : {"Name": "High Memory Nodes","Field":"AvailableFeatures","Value":"hi_mem","Priority":3}
              }

# This was built into the script for University of Arizona's systems. We have nodes with 96 CPUs
# where two are reserved for system use. This leaves 94 available for users to schedule. If there are
# machines where fewer CPUs are schedulable than exist on the system, this variable's format should be:
# cpu_limits = {physical_cpus1:schedulable_cpus1,physical_cpus2:schedulable_cpus2,...}
# if this is not applicable, set cpu_limits to None.
global cpu_limits
cpu_limits = {"96":"94"}












'''
------------------------------------------------------------------------------------------
##########################################################################################
                                    Subroutines                                
##########################################################################################
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
                                   Vis Options
******************************************************************************************
'''
class VisOptions:
    def __init__(self,seed, use_ascii):
        
        # Seed option determines if display colors are rapndomized
        self.seed = seed
        self.use_ascii = use_ascii
        self.width = 0
        self.max_cpus= 0
        self.max_gpus=0
        self.valid_annotations = set({})

    # The different color options are for highlighting resources being used by a 
    # group/user/partition, if requested. Additionally, nodes in the DOWN/DRAIN
    # state will be highlighted with the DOWNCOLOR.
    COLOR="\033[38;5;%dm"
    DOWNCOLOR="\033[0;31m"
    DOWNUSEDCOLOR=COLOR%int(181)
    ENDCOLOR="\033[0m"

    # Blocks used to display resource usage. Want to use a different utf-8 character?
    # https://www.w3schools.com/charsets/ref_utf_geometric.asp
    utf8_char = u'\u258B'
    ascii_char = '#'
    scale_utf8_char = u'\u2592'
    
    # A range of randomized colors is also generated for color-coding different jobs
    # if the "--node=nodename" option is given. This is generally deterministic, 
    # unless the --randomize flag is used. 
    def color_cycle(self):
        cycle = [self.COLOR%i for i in range(0,256)]
        if self.seed == None:
            random.seed(110)
        if self.seed != None:
            random.seed(seed)
        random.shuffle(cycle)
        return cycle






'''
WHY NOT LET'S JUST MAKE THIS PROCESS STUPID AND MAKE THIS A CLASS WOOOOO
------------------------------------------------------------------------------------------
                                     Job Options
Options include --user=username, --partition=queue, --help, and --node=nodename, --ascii
'''
class Args:
    def __init__(self,argv):
        
        self.argv = argv
        
        self.partition=self.user=self.group=self.node=None
        self.all_nodes=self.color_random=self.use_ascii=self.scale=False
        self.scale_ratio=1
        try:
            opts,args = getopt.getopt(argv, "harsw:p:u:n:g:",["help","all","randomize","ascii","partition=","user=","group=","node=","scale","width="])
            if len(opts) ==0:
                return
        except getopt.GetoptError:
            print("Unrecognized Option")
            usage(1)
        for opt, arg in opts:
            if opt in ("-h","--help"):
                usage(0)
            elif opt in ("-p","--partition"):
                self.partition = arg.lower()
            elif opt in ("-u","--user"):
                self.user = arg.lower() 
            elif opt in ("-n","--node"):
                self.node = arg.lower()
            elif opt in ("-a","--all"):
                self.all_nodes = True
            elif opt in ("-g","--group"):
                self.group = arg.lower()
            elif opt in ("-r","--randomize"):
                self.color_random = True
            elif opt == "--ascii":
                self.use_ascii=True
            elif opt in ("-s","--scale"):
                self.scale = True
                self.scaled_width=70
            elif opt in ("-w","--width"):
                try:
                    self.scale = True
                    self.scaled_width=int(arg)
                except ValueError:
                    print("Width must be an integer")
                    usage(1)
            else:
                print("Unrecognized option.")
                usage(1)
        if [self.partition,self.user,self.group,self.node].count(None) < 3:
            print("Too many options specified")
            usage(1)



'''
------------------------------------------------------------------------------------------
                                    Get Partitions
Get valid partitions available on the cluster
'''
def get_partitions():
    p = subprocess.Popen(['sinfo --federation --format=%R --noheader'],stdout=subprocess.PIPE,shell=True)
    out,err = p.communicate()
    if err != None and err.decode("utf-8") != "":
        print("Oops, something has gone wrong! Error occured running:\n\t'sinfo --federation --format=%R --noheader'\nThis could be a problem with your SLURM setup. Exiting.")
        sys.exit(1)
    output = out.decode('utf-8').split("\n")
    partitions = [i for i in output if i != '']
    return partitions




'''
------------------------------------------------------------------------------------------
                                      Usage
Only used to print the usage message. Exits with provided value after print
'''
def usage(exit_value):
    print("Usage: nodes-busy [--OPTION=VALUE|--VIS_OPTIONS|--help]")
    print("\nValid OPTION/VALUE combinations : Only one OPTION/VALUE can be specified")
    print("  --partiton=<partition*>       : Highlights all CPUs/GPUs reserved by specified partition")
    print("  --user=netid                  : Highlights all CPUs/GPUs reserved by <netid>'s jobs")
    print("  --group=gid                   : Highlights all CPUs/GPUs reserved by <gid>'s jobs")
    print("\nValid VIS_OPTIONS               : Optional. More than one can be selected")
    print("  --ascii                       : Use ascii encoding instead of utf-8. Can resolve formatting")
    print("                                : issues (e.g. in OOD terminals)")
    print("  --random                      : Just for fun, mix up the color display")
    print("  --all                         : Include all system nodes in --user and --group output")
    print("  --scale                       : Scales node sizes down to 80 characters")
    print("\n*Valid partitions: "+",".join(get_partitions())+"\n")
    sys.exit(exit_value)




'''
******************************************************************************************
------------------------------------------------------------------------------------------
                                  Splitting Node Names
Slurm tries to make for nice output by representing nodes in formats like:
cpu1,cpu31,cpu[45-46,48,51-55],cpu[57-58],cpu[59-60,63],cpu[70,74]...
which is a bummer to parse. These functions are dedicated to untangling this.

'''

# This bit catches the cases where a node name might be something like node01
# since this might be stored as node
def store_leading_zero(index):
    if index[0] != "0" or index == "0":
        prefix=""
    else:
        prefix = ""
        for i in range(0,len(index)+1):
            if index[i] =="0":
                prefix += index[i]
            else:
                break
    return prefix

# This section has been changed after discovering some edge cases that made the
# old version fail. This formatting is a nightmare to disentangle. I'll try to 
# annotate for future screaming matches with my computer:

# Tested on:
# r2u13n2,r2u25n1,r2u26n1,r2u28n1
# gpu[1-50,76,78-90]
# exp-1-[25-26],exp-2-[47-48],exp-3-[01-02,37-38],exp-4-[47-48],exp-5-[08-09,56],exp-8-[01-02],exp-14-[16-18],exp-30-20,exp-25-01
# r3u08n2,r3u12n2,r3u14n1,r3u16n2,r3u17n[1-2]

def split_node_format(NodeList,cpus):
    split_nodes = []
    # We split up our list of nodes into groups with the specific intent of 
    # separating node prefixes from their possible index ranges
    split_groups = [i for i in re.findall("([\w\[,\-]*)",NodeList) if i != ""]
    for i in split_groups:
        # Scrub the node name prefix of any leading commas
        if "," == i[0]:
            i = i[1:]
        # If there aren't any brackets, then the names are well-behaved and 
        # we can split them easily using commas. However, if there are brackets,
        # we need to unpack the index values. 
        if "[" in i:
            node_prefix,indices = i.split("[")
            # Unpack any 
            if "," in node_prefix:
                node_cluster = node_prefix.split(",")
                leading_nodes = node_cluster[:-1]
                node_prefix= node_cluster[-1]
                split_nodes += [(n,cpus) for n in leading_nodes]
            v_ranges = indices.split(",")

            for r in v_ranges:
                r_split = r.split("-")
                if len(r_split) == 1:
                    split_nodes.append((node_prefix+r_split[0],cpus))
                else:
                    first_index, second_index = r_split
                    leading_val = store_leading_zero(first_index)
                    index_range = range(int(first_index),int(second_index)+1)
                    for index in index_range:
                        if len(str(index)) > 1:# and node_prefix + leading_val + str(index) not in nodes_dictionary.keys():
                            split_nodes.append((node_prefix + str(index),cpus))
                        else:
                            split_nodes.append((node_prefix + leading_val + str(index),cpus))
        else:
            split_nodes += [(n,cpus) for n in i.split(",")]


    return split_nodes




'''
------------------------------------------------------------------------------------------
                                 Pull Job Data
Uses "scontrol show job -d --oneliner" to grab detailed data on every job running on the 
cluster. Specs are pulled from these to determine the number of GPUs, CPUs, etc. reserved. 
Also pulls the job queue for the --partition option.
'''
def get_scontrol_job_data(target_job = None):
    fields = ["JobId","Partition","Restarts","EndTime","TimeLimit","NodeList","NumNodes","NumCPUs","NumTasks","TRES","JOB_GRES","Nodes","Features","CPU_IDs","TresPerNode"]
    job_data = {}
    if target_job == None:
        p = subprocess.Popen(['scontrol show job -d --oneliner | grep "JobState=RUNNING"'],stdout=subprocess.PIPE, shell=True)
    else:
        p = subprocess.Popen(['scontrol show job -d --oneliner '+target_job+' | grep "JobState=RUNNING"'],stdout=subprocess.PIPE,stderr=subprocess.PIPE, shell=True)
    out,err = p.communicate()

    if err != None and err.decode("utf-8") != "":
        print("Oops, something has gone wrong!\nIf you've included a Job ID, check that it's valid and try again.")
        sys.exit(1)
    
    # Split up space-delimited output into a job dictionary 
    output = out.decode('utf-8').split("\n")
    for job in output:
        details = job.split(' ')
        for i in details:
            # Fields and their values are separated by "="
            job_entry = i.split("=")

            # We only care about the fields we've defined, so we ignore the rest
            if job_entry[0] in fields:
                if job_entry[0] == "JobId":
                    JobId = job_entry[1]
                    job_data[JobId] = {"Individual Nodes" : {},"GPUAlloc":0}
                elif job_entry[0] =="Nodes":
                    current_node = job_entry[1]
                    job_data[JobId]["Individual Nodes"][current_node] = None
                elif job_entry[0] == "CPU_IDs":
                    cpus_assigned = 0
                    ids = job_entry[1].split(',')
                    for ID_set in ids:
                        split_set = ID_set.split("-")
                        if len(split_set) == 1:
                            cpus_assigned +=1
                        else:
                            cpus_assigned += len(range(int(split_set[0]),int(split_set[1]))) + 1
                    job_data[JobId]["Individual Nodes"][current_node] = cpus_assigned

                elif job_entry[0] == "TresPerNode":
                    gpu_opts = job_entry[1]
                    if gpu_opts == "(null)":
                        job_data[JobId]["GPUAlloc"] = 0
                    elif gpu_opts == "gpu":
                        job_data[JobId]["GPUAlloc"] = 1
                    else:
                        job_data[JobId]["GPUAlloc"] = gpu_opts.split(":")[-1]

                else:
                    entry_label = job_entry[0]
                    entry_data = job_entry[1]
                    job_data[JobId][entry_label] = entry_data
        # Catch all instances of node name reformatting so the jobs can be
        # matched 
        remove, add = [],[]
        for entry,cpus in job_data[JobId]["Individual Nodes"].items():
            if "," in entry or "[" in entry:
                remove.append(entry)
                nodes = split_node_format(entry,cpus)
                add += nodes
        for entry in remove:
            job_data[JobId]["Individual Nodes"].pop(entry)
        for entry in add:
            job_data[JobId]["Individual Nodes"][entry[0]] = entry[1]
    return job_data



'''
------------------------------------------------------------------------------------------
                                  Get Node Data
Get all data from nodes and arrange into dictionary. This can be merged with the job data 
to get comprehensive information about system use.
'''
def get_scontrol_node_data():

    max_cpus = 0
    # Used to collect the reasons nodes may be in the down/drain state
    node_data = {"REASONS":{}}
    n = 1
    fields = ["NodeName","CPUAlloc","CPUTot","AvailableFeatures","AllocTRES","CfgTRES","State","Reason","Partitions","Gres"]
    ufields = {}
    # node_types is defined as a global variable at the start of the script. This is to differentiate
    # standard, gpu, high memory, etc. nodes. 
    for i in node_types.items():
        k,v,f = i[0],i[1]["Value"],i[1]["Field"]
        # Setting the specific node type to none is how a node type is made the default categorization
        if f != None:
            # There may be multiple fields associated with a node type. This catches that case.
            if type(f) == list:
                for f_i in f:
                    ufields[f_i] = (v,k)
            else:
                ufields[f] = (v,k)
    uvalues = {}
    for i in node_types.items():
        k,v = i[0],i[1]["Value"]
        if v != None:
            uvalues[v] = k

    # Node information is collected from scontrol and arranged into a dictionary.            
    p = subprocess.Popen(['scontrol show nodes --all --oneliner'],stdout=subprocess.PIPE,shell=True)
    out,err = p.communicate()
    node_output = out.decode('utf-8').split("\n")
    for i in node_output:
        node_specs = i.split(" ")
        for j in node_specs:
            field = j.split("=")[0]
            if field in fields:
                # Since NodeName is the first field, this is where we add preliminary data.
                # Standard Nodes are the assumed default (this can be renamed in the user
                # options). This may be altered if other node specs defined in node_types
                # are found. 
                if field == "NodeName":
                    Node_Name = j.split("=")[-1]
                    node_data[Node_Name]={"Node_Type":node_types["Standard Nodes"]["Name"],"Annotation":None}
                    
                # Add annotations if field and value match user specifications
                if node_annotations != None and j.split("=")[1] in [i["Value"] for i in node_annotations.values()]:
                    for f,v in node_annotations.items():
                        if v["Field"] == field and v["Value"] == j.split("=")[1]:
                            node_data[Node_Name]["Annotation"] = {"Ascii": v["Ascii Symbol"],"UTF-8": v["UTF-8 Symbol"]}

                # Next, we check if a specified node type was found
                if field in ufields.keys():
                    if ufields[field][0] in j:
                        # I know, this is nested chaos... I'm sorry
                        # All that's happening is that the node grouping
                        # is being checked to see if it should be changed
                        current_priority = node_types[node_data[Node_Name]["Node_Type"]]["Priority"]
                        check_priority = node_types[ufields[field][1]]["Priority"]
                        if check_priority > current_priority:
                            node_data[Node_Name]["Node_Type"] = ufields[field][1]

                # SLURM shows GPUs either in AllocTRES or CfgTRES. 
                if field == "AllocTRES" or field == "CfgTRES":
                    if "gpu" in j:
                        gpu_count = j.split("gpu")[-1].split("=")[-1]
                        node_data[Node_Name][field] = gpu_count

                # This bit grabs why a node is down/draining
                # Reasons may include spaces and the node specs are space-delimited
                # (sigh), so this gets the full reason 
                elif field == "Reason":
                    reason = i.split("Reason=")[-1].split(" Comment=")[0] 
                    removal = re.search('\[[^\]]*\]',reason)
                    initiator = removal.group(0)
                    reason = reason.replace(initiator,"")
                    if reason not in node_data["REASONS"]:
                        node_data["REASONS"][reason]=n
                        node_data[Node_Name]["Reason"] =n
                        n+=1
                    else:
                        node_data[Node_Name]["Reason"] =node_data["REASONS"][reason]
                elif field == "State":
                    state = j.split("=")[-1]
                    if "DOWN" in state:
                        node_data[Node_Name]["State"] = "DOWN"
                    elif "DRAIN" in state:
                        node_data[Node_Name]["State"] = "DRAIN"
                    else:
                        node_data[Node_Name]["State"]="UP"
                elif field == "CPUTot":
                    cpu_count = int(j.split("=")[-1])
                    if cpu_limits != None and str(cpu_count) in cpu_limits.keys():
                        cpu_count = int(cpu_limits[str(cpu_count)])
                    if cpu_count > max_cpus:
                        max_cpus = cpu_count
                    node_data[Node_Name][field] = cpu_count
                    percentage = str(round(100*(int(node_data[Node_Name]["CPUAlloc"])/cpu_count),2))+"%"
                    percentage = " "*(6-len(percentage))+percentage
                    node_data[Node_Name]["CPU_PERCENT"] = percentage
                else:
                    node_data[Node_Name][field] = j.split("=")[-1]
    node_data["MAX_CPUS"] = max_cpus
    return node_data




'''
------------------------------------------------------------------------------------------
                                   Get User Job IDs
If the --user option is supplied, that user's job IDs are pulled and returned as a list
'''
def get_user_jobids(username,group):
    user_job_data = []
    if username != None:
        p = subprocess.Popen(['squeue --noheader --states=RUNNING -o %A --user '+username],stdout=subprocess.PIPE, shell=True)
    elif group != None:
        p = subprocess.Popen(['squeue --noheader --states=RUNNING -o %A --account '+group],stdout=subprocess.PIPE, shell=True)
    out,err = p.communicate()
    user_jobs = out.decode('utf-8').split("\n")
    for job in user_jobs:
        formatted_job = [i for i in job.split(" ") if i != ""]
        if len(formatted_job) != 0:
            JobID = formatted_job[0]
            Job_Components = JobID.split("_")
            Job_Base = Job_Components[0]
            try:
                # IDs are reformatted in the event of job arrays
                Job_indices = Job_Components[1].replace("[","").replace("]","")
                Indices_boundaries = Job_indices.split("-")
                Full_indices = range(int(Indices_boundaries[0]),int(Indices_boundaries[1])+1)
                for index in Full_indices:
                    Full_job_id = Job_Base+"_"+str(index)
                    user_job_data.append(Full_job_id)
            except IndexError:
                user_job_data.append(JobID)
    return user_job_data




'''
------------------------------------------------------------------------------------------
                                          Merge
Merge the jobs and nodes dictionary together to get comprehensive data on system use. 
'''
def merge(jobs_dictionary, nodes_dictionary):
    for job in jobs_dictionary.keys():
        for node,cpus in jobs_dictionary[job]["Individual Nodes"].items():
            if "JOBS" not in nodes_dictionary[node].keys():
                nodes_dictionary[node]["JOBS"] = {}
            nodes_dictionary[node]["JOBS"][job] = {"CPUs":cpus, "GPUs":jobs_dictionary[job]["GPUAlloc"],"EndTime":jobs_dictionary[job]["EndTime"],"Partition":jobs_dictionary[job]["Partition"],"Restarts":jobs_dictionary[job]["Restarts"]}
    return nodes_dictionary





'''
******************************************************************************************
------------------------------------------------------------------------------------------
                                         Usage Bar
Create a usage bar for each node, highlighting any CPUs or GPUs based on user options
'''
def usage_bar(usage_block,num_used,num_highlighted,total_cpus,state,vis):
    if state in ["DOWN","DRAIN"]:
        HIGHLIGHTCOLOR=vis.DOWNUSEDCOLOR
        UNHIGHLIGHTCOLOR = vis.DOWNCOLOR
    else:
        HIGHLIGHTCOLOR = vis.color_cycle()[0]
        UNHIGHLIGHTCOLOR = vis.ENDCOLOR
    used = int(num_used)
    highlighted = int(num_highlighted)
    unhighlighted = used - num_highlighted
    total_cpus = int(total_cpus)
    blank = total_cpus - used

    usage = UNHIGHLIGHTCOLOR+"["+usage_block*unhighlighted+HIGHLIGHTCOLOR+usage_block*highlighted+UNHIGHLIGHTCOLOR+" "*blank+"]"+vis.ENDCOLOR
    return usage


'''
------------------------------------------------------------------------------------------
                                        Highlight
In case --user or --partition has been included, the CPUs/GPUs associated with the request
need to be highlighted with a color. This grabs the number that need to be highlighted
'''
def highlight(node_list, node_dictionary, partition, user,group):
    if partition != None:
        for data in node_list:
            node,CPUAlloc = data
            highlighted_cpus = 0
            highlighted_gpus = 0
            try:
                for job,job_data in node_dictionary[node]["JOBS"].items():
                    if job_data["Partition"] == partition:
                        highlighted_cpus += int(job_data["CPUs"])
                        highlighted_gpus += int(job_data["GPUs"])
                    else:
                        pass
            except KeyError:
                highlighted_cpus = 0
                highlighted_gpus = 0
            node_dictionary[node]["highlighted_cpus"] = highlighted_cpus
            node_dictionary[node]["highlighted_gpus"] = highlighted_gpus
    elif user != None or group != None:
        user_job_list = get_user_jobids(user,group)
        for data in node_list:
            node,CPUAlloc = data
            highlighted_cpus =0
            highlighted_gpus =0
            try:
                for job, job_data in node_dictionary[node]["JOBS"].items():
                    if job in user_job_list:
                        highlighted_cpus += int(job_data["CPUs"])
                        highlighted_gpus += int(job_data["GPUs"])
                    else:
                        pass
            except KeyError:
                highlighted_cpus = 0
                highlighted_gpus = 0
            node_dictionary[node]["highlighted_cpus"] = highlighted_cpus
            node_dictionary[node]["highlighted_gpus"] = highlighted_gpus
    else:
        for data in node_list:
            node,CPUAlloc = data
            highlighted_cpus = 0
            highlighted_gpus = 0
            node_dictionary[node]["highlighted_cpus"] = highlighted_cpus
            node_dictionary[node]["highlighted_gpus"] = highlighted_gpus

    return node_dictionary


'''
------------------------------------------------------------------------------------------
                                   Format String
Create a formatted string for printing output.
'''
def format_string(down,gpu,max_cpus,DOWNCOLOR,ENDCOLOR,max_gpus=None):
    if down == True and gpu == False:
        formatting_string = DOWNCOLOR + "{0:7}:{1:"+str(max_cpus+2)+"}"+DOWNCOLOR+" {2:>5} {3:6}[{4:1}] {5:2}"+ENDCOLOR
    elif down == False and gpu == False:
        # Expecting input (node name, usage bar, percentage)
        formatting_string = formatting_string ="{0:7}:{1:"+str(max_cpus+2)+"} {2:*>5} {3:2}"
    elif down == True and gpu == True:
        # Expecting input (node name, usage bar, percentage, GPU usage bar, GPU percentage, state, reason index)
        formatting_string = DOWNCOLOR+"{0:7}:{1:"+str(max_cpus+2)+"}"+DOWNCOLOR+" {2:>5} {3:"+str(max_gpus+2)+"} "+DOWNCOLOR+"{4:>5} {5:6}[{6:1}] {7:2}" + ENDCOLOR
    elif down == False and gpu == True:
        # Expecting input (node name, usage bar, percentage, GPU usage bar, GPU percentage)
        formatting_string = "{0:7}:{1:"+str(max_cpus+2)+"} {2:>6} {3:"+str(int(max_gpus)+3)+"} {4:<6} {5:2}"
    return formatting_string



'''
------------------------------------------------------------------------------------------
                                   Sort Node Types
Takes each node type defined by the user and sorts into a list based on cpu usage. Also
returns max cpus and max gpus on the cluster for formatting purposes.
'''
def sort_node_types(node_specs):
    max_cpus = 0
    max_gpus = 0 

    sorted_specs = {}
    
    for ntype in node_types.keys():
        sorted_specs[ntype] = []
        
    for key, data in node_specs.items():
        if key in ("REASONS","MAX_CPUS"):
            pass
        else:
            Node_Type = data["Node_Type"]
            CPUAlloc = int(data["CPUAlloc"])
            TotalCPU = int(data["CPUTot"])
            if TotalCPU > max_cpus:
                max_cpus = TotalCPU
            if Node_Type in node_types.keys():
                sorted_specs[Node_Type].append((key,CPUAlloc))
            try:
                TotalGPU = int(data["CfgTRES"])
            except KeyError:
                TotalGPU = 0
            if TotalGPU > max_gpus:
                max_gpus = TotalGPU
                
    for i in sorted_specs.values():
        i.sort(key=lambda x: x[1], reverse=True)
    return sorted_specs, max_cpus, max_gpus


'''
------------------------------------------------------------------------------------------
                                      Scale

'''
def scale(node_specs,job_options,vis):

    scale_factor = job_options.scale_ratio
    for node,value in node_specs.items():
        if node in ("REASONS","MAX_CPUS"):
            pass
        else:
            true_fraction = float(value["CPUAlloc"])/float(value["CPUTot"])
            new_tot = math.ceil(int(value["CPUTot"])*scale_factor)
            scaled_usage = round(new_tot*true_fraction)

            value["CPUAlloc"] = scaled_usage
            value["CPUTot"] = new_tot
            if len(value)> 1 and "JOBS" in value.keys():
                for job,job_specs in value["JOBS"].items():
                    scaled_cpus = round(int(job_specs["CPUs"])*scale_factor)
                    value["JOBS"][job]["CPUs"] = scaled_cpus

    return node_specs



'''
------------------------------------------------------------------------------------------
##########################################################################################
                                Display Subroutines                                
##########################################################################################
------------------------------------------------------------------------------------------
                                  Print Header
                                  
******************************************************************************************

Print header for the output. Not a whole lot going on here aside from displaying the
current time, giving the output a nice header, and double-checking that utf-8 encoding
is enabled. 
'''
def print_header(width,job_options):
    ENDCOLOR = vis.ENDCOLOR
    cycle = vis.color_cycle()
    
    # Formats the current day/time into something that can be displayed nicely
    # The time_spacing is used to center the message.
    today = datetime.datetime.now()
    time_string = "%s"%today.strftime("%a %b %d, %I:%M:%S %p (MST) %G")
    time_string_length = len(time_string)
    time_spacing = math.ceil(width/2) - math.ceil(time_string_length/2)

    # Similar to above, heading_spacing is used to center the header string
    heading_string = " System Status "
    heading_spacing = math.ceil(width/2) - math.ceil((len(heading_string)+2)/2)
    
    if job_options.use_ascii == False:
        block = vis.utf8_char
    else:
        block = vis.ascii_char
        
    print("="*width)
    
    # if anything is wonky with the user's environment (e.g. the python encoding 
    # variable is set to use ascii, this will catch it. 
    try:
        print("\n"+" "*heading_spacing +  block + heading_string + block)
    except UnicodeEncodeError:
        block = vis.ascii_char
        job_options.use_ascii = True
        print("\n"+" "*heading_spacing +  block + heading_string + block)
        
    print(" "*time_spacing + time_string)
    
    if partition != None:
        partition_string = "Highlighting resources reserved by the %s partition"%partition
        partition_spacing = math.ceil(width/2) - math.ceil(len(partition_string)/2)
        print(cycle[0]+" "*partition_spacing + partition_string + ENDCOLOR)
    elif user != None:
        user_string = "Highlighting resources reserved by user: %s"%user
        user_spacing = math.ceil(width/2) - math.ceil(len(user_string)/2)
        print(cycle[0]+" "*user_spacing + user_string + ENDCOLOR)
    elif group != None:
        group_string = "Highlighting resources reserved by group: %s"%group
        group_spacing = math.ceil(width/2) - math.ceil(len(group_string)/2)
        print(cycle[0]+" "*group_spacing + group_string + ENDCOLOR)
    return job_options
    

'''
******************************************************************************************
CHECK THAT ALL THE CONSTANTS ARE NEEDED
------------------------------------------------------------------------------------------
                                Display Node Type
'''                                
def display_node_type(node_specs,ntype,nval,job_options,vis):
    #partition,user,group, node,all_nodes,color_random, use_ascii= job_options
    # Get vis options
    ENDCOLOR = vis.ENDCOLOR
    DOWNCOLOR = vis.DOWNCOLOR
    DOWNUSEDCOLOR = vis.DOWNUSEDCOLOR
    width = vis.width
    max_cpus = vis.max_cpus
    max_gpus = vis.max_gpus
    

    # Get user options
    user = job_options.user
    group=job_options.group
    partition=job_options.partition
    all_nodes = job_options.all_nodes

    # Choose usage block based on whether ascii is needed
    if vis.use_ascii == True:
        block = vis.ascii_char
    else:
        block = vis.utf8_char

    # Color cycle for highlighting usage 
    cycle = vis.color_cycle()
    # If a particular node type isn't found, the header/non-existent values aren't
    # displayed
    if len(nval) == 0:
        pass
    else:
        print("\n"+ntype+"\n"+"="*width)
        node_specs = highlight(nval,node_specs,partition,user,group)
        jobs_found = False
        for data in nval:
            node,CPUAlloc = data
            highlighted = node_specs[node]["highlighted_cpus"]
            highlighted_gpus = node_specs[node]["highlighted_gpus"]
            if node_specs[node]["Annotation"] ==None:
                annotate= ""
            elif vis.use_ascii == True:
                annotate = node_specs[node]["Annotation"]["Ascii"]
                vis.valid_annotations.add(annotate)
            else:
                annotate = node_specs[node]["Annotation"]["UTF-8"]
                vis.valid_annotations.add(annotate)
            
            # Add bit about annotation here. Specifically related to "annotate" Will ignore until user options are more well-defined
            if (user != None or group != None) and highlighted == 0 and all_nodes==False:
                pass
            else:
                jobs_found = True
                total_cpus = node_specs[node]["CPUTot"]
                percentage = node_specs[node]["CPU_PERCENT"]
                if cpu_limits != None and total_cpus in cpu_limits.keys():
                    total_cpus = cpu_limits[total_cpus]
                #percentage = str(round(100*(int(CPUAlloc)/int(total_cpus)),2))+"%"
                #percentage = " "*(6-len(percentage))+percentage
                state = node_specs[node]["State"]
                usage = usage_bar(block,CPUAlloc,highlighted,total_cpus,state,vis)
                
                # Check to see if this is a GPU node
                try:
                    total_gpus = int(node_specs[node]["CfgTRES"])
                except KeyError:
                    total_gpus = 0
                # Even if this is a GPU node, GPUs may not be used. Catch this case here.
                try:
                    total_gpus_used = sum([int(job["GPUs"]) for job in node_specs[node]["JOBS"].values()])
                except KeyError:
                    total_gpus_used = 0
                if total_gpus != 0:
                    gpu_usage = usage_bar(block,total_gpus_used,highlighted_gpus,total_gpus,state,vis)+" "*(int(max_gpus)-int(total_gpus)+2)
                    gpu_percentage = str(round(100*(int(total_gpus_used)/int(total_gpus)),2))+"%"
                    gpu_percentage = " "*(6-len(gpu_percentage))+gpu_percentage
                
                
                if state not in ["DOWN","DRAIN"]:
                    if total_gpus == 0:
                        formatting_string = format_string(False,False,max_cpus,DOWNCOLOR,ENDCOLOR)
                        print(formatting_string.format(node,usage,percentage,annotate))
                    else:
                        formatting_string = format_string(False,True,max_cpus,DOWNCOLOR,ENDCOLOR,max_gpus)
                        print(formatting_string.format(node,usage,percentage,gpu_usage,gpu_percentage,annotate))
                else:
                    reason = node_specs[node]["Reason"]
                    if total_gpus == 0:
                        formatting_string = format_string(True,False,max_cpus,DOWNCOLOR,ENDCOLOR)
                        print(formatting_string.format(node,usage,percentage,state,reason,annotate))
                    else:
                        formatting_string = format_string(True,True,max_cpus,DOWNCOLOR,ENDCOLOR,max_gpus)
                        print(formatting_string.format(node,usage,percentage,gpu_usage,gpu_percentage,state,reason,annotate))
        if jobs_found == False and user != None:
            print("No user jobs found")
        if jobs_found == False and group != None:
            print("No jobs matching %s group"%group)
        elif jobs_found == False and user == None:
            print("No nodes found")




'''
******************************************************************************************
CHECK THAT ALL CONSTANTS ARE NEEDED. 
------------------------------------------------------------------------------------------
                                      Display
Goes through the whole process of sorting data, highlighting, checking user options, 
getting usage bar, and printing headers/formatting etc. 
'''
def display(node_specs,job_options,vis):

    # Some color options defined in the vis class at the beginning of this script. Used for
    # highlighting selected users, groups, and partitions, or picking out down/draining
    # nodes.
    ENDCOLOR = vis.ENDCOLOR
    DOWNCOLOR = vis.DOWNCOLOR
    DOWNUSEDCOLOR = vis.DOWNUSEDCOLOR
    cycle = vis.color_cycle()
    max_cpus = node_specs["MAX_CPUS"]
    if job_options.scale == True and max_cpus > job_options.scaled_width:
        job_options.scale_ratio = job_options.scaled_width/max_cpus
        node_specs=scale(node_specs,job_options,vis)
        vis.utf8_char=vis.scale_utf8_char

    
    # We sort nodes based on CPU usage. This makes it so when all nodes are displayed, 
    # CPU usage will be shown in decending order
    sorted_specs, max_cpus, max_gpus = sort_node_types(node_specs)
    

    
    # Added new submodule to print the header as its own bit. Attempting to make this whole
    # display section less redundant/less of a mess.
    width = max_cpus + max_gpus + 30


    
    vis.width = width
    vis.max_cpus = max_cpus
    vis.max_gpus = max_gpus
    
    job_options = print_header(vis.width,job_options)
    # Goes through each node type and prints a visualization of usage
    for ntype, nval in sorted_specs.items():
        display_node_type(node_specs,ntype,nval,job_options,vis)
    
    # prints reasons why nodes are down or draining. 
    if len(node_specs["REASONS"].items()) != 0:
        print("\n\nDown/Drain* Node Reasons")
        print("="*width)
        for i,j in node_specs["REASONS"].items():
            print("[%s] %s"%(j,i))
        print("\n* Nodes in the DRAIN state will wait for all running jobs to complete\nand will not accept new jobs without manual intervention\n")


    
    if len(vis.valid_annotations) != 0:
        print("\nNode Annotations"+"\n"+"="*width)
        for a,v in node_annotations.items():
            if vis.use_ascii == True:
                a_s = v["Ascii Symbol"]
            else:
                a_s = v["UTF-8 Symbol"]
            if a_s in vis.valid_annotations:
                print("{0:4} {1:100}".format(a_s,v["Message"]))
    return
    
    






'''
******************************************************************************************
HAVEN'T EVEN STARTED HERE -_-
------------------------------------------------------------------------------------------
                                Single Node Display
If the --node=<node_name> option is used, a single usage bar will appear with color-coded
blocks that display resources reserved on that node by job. This information includes CPU
count, GPU count (if applicable), job partition, job end time, and number of job 
interrupts. 
'''

def single_node_display(node,node_dictionary,use_ascii,vis):
    # First, we'll check that the node name actually exists on the system
    if node not in node_dictionary.keys():
        print("Oops! Node not found on cluster. Check your input and try again.")
        usage(1)

    # If utf-8 encoding isn't supported in the user's environment, we'll switch to ascii
    message = "Displaying usage info for node: %s"%node
    if vis.use_ascii == True:
        block = vis.ascii_char
    else:
        block = vis.utf8_char
    try:
        print("\n%s %s %s"%(block, message,block))
    except UnicodeEncodeError:
        block = vis.ascii_char
        print("\n%s %s %s"%(block, message,block))
    print("="*len(message))

    
    node_specific_dictionary = node_dictionary[node]
    state = node_specific_dictionary['State']
    node_type = node_specific_dictionary["Node_Type"]
    allowed_partitions=set(node_specific_dictionary["Partitions"].split(","))
    print(node_specific_dictionary["Annotation"])
    sys.exit(0)
    if allowed_partitions == set(["windfall","high_priority"]):
        buy_in = True
    else:
        buy_in = False
    # If the node is down or draining, we figure out why
    if state in ["DOWN","DRAIN"]:
        for r,index in node_dictionary["REASONS"].items():
           if node_specific_dictionary["Reason"] == index:
               reason = r
               break
    # Since we're only interested in one node, let's dump the rest
    del node_dictionary


    total_cpus = int(node_specific_dictionary["CPUTot"])
    color_index = 0
    color_cycle = vis.color_cycle()
    cpu_usage_bar = "["
    try:
        for job,data in node_specific_dictionary["JOBS"].items():
            color = color_cycle[color_index]
            node_specific_dictionary["JOBS"][job]["color"] = color
            num_cpus = int(data["CPUs"])
            cpu_usage_bar += color + block * num_cpus + vis.ENDCOLOR
            color_index += 1
    except KeyError:
        pass
    used_cpus = int(node_specific_dictionary["CPUAlloc"])
    unused_cpus = total_cpus - used_cpus
    cpu_usage_bar = cpu_usage_bar + " "*unused_cpus+ "]"
    used_gpus = 0
    # Get GPUs if applicable
    if node_type == "GPU":
        total_gpus = int(node_specific_dictionary["CfgTRES"])
        gpu_usage_bar = "["
        try:
            for job,data in node_specific_dictionary["JOBS"].items():
                color = data["color"]
                num_gpus = int(data["GPUs"])
                used_gpus += num_gpus
                gpu_usage_bar += color + block * num_gpus + vis.ENDCOLOR
        except KeyError:
            pass
        unused_gpus = total_gpus - used_gpus
        gpu_usage_bar = gpu_usage_bar + " "*unused_gpus +"]"
        gpu_percentage_usage = str(round(100*(used_gpus/total_gpus),2)) + "%"
    percentage_usage = str(round(100*(used_cpus/total_cpus),2)) + "%"


    # Print Node Data
    DOWNCOLOR = vis.DOWNCOLOR
    ENDCOLOR = vis.ENDCOLOR
    if state in ["DOWN","DRAIN"]:
        print(DOWNCOLOR+"State: %s -- %s"%(state,reason)+ENDCOLOR)
    else:
        print("State: %s"%state)
    print("Node Type: %s"%node_type)
    print("Buy-In Node: %s  **"%buy_in)
    print("Number of jobs running: %s"%color_index)
    print("CPUs Available: %s | CPUs Used: %s | Percent Utilized: %s"%(total_cpus,used_cpus,percentage_usage))
    if node_type == "GPU":
        print("GPUs Available: %s | GPUs Used: %s | Percent Utilized: %s"%(total_gpus,used_gpus,gpu_percentage_usage))
    print()
    if node_type =="GPU":
        format_string = "{0:"+str(len(node))+"} {1:"+str(total_cpus+3)+"} {2:"+str(total_gpus+3)+"}"
        print(format_string.format("Node","CPU Usage","GPU Usage"))
        print("%s:%s  %s"%(node,cpu_usage_bar,gpu_usage_bar))
    else:
        format_string = "{0:"+str(len(node))+"} {1:"+str(total_cpus+3)+"}"
        print(format_string.format("Node","CPU Usage"))
        print("%s:%s"%(node,cpu_usage_bar))
    print("\nJobs")
    print("="*len(message))
    if node_type == "GPU":
        job_formatting_string = "{0:10} {1:8} {2:10} {3:4} {4:4} {5:8} {6:15}"
        print(job_formatting_string.format("Color","Job ID","Partition","CPUs","GPUs","Restarts","End Date/Time"))
    else:
        job_formatting_string = "{0:10} {1:8} {2:10} {3:4} {4:8} {5:15}"
        print(job_formatting_string.format("Color","Job ID","Partition","CPUs","Restarts","End Date/Time"))
    try:
        for job,data in node_specific_dictionary["JOBS"].items():
            color = data["color"]
            identifier = color + block + ENDCOLOR + 9*" "
            end_time = data["EndTime"].replace("T","/")
            if node_type == "GPU":
                print(job_formatting_string.format(identifier, str(job), data["Partition"],str(data["CPUs"]),str(data["GPUs"]),data["Restarts"],end_time))
            else:
                print(job_formatting_string.format(identifier, str(job), data["Partition"],str(data["CPUs"]),data["Restarts"],end_time))
    except KeyError:
        print("None")

    print("** Buy-in nodes only accept high_priority and windfall jobs")
    
    
    
    
    
    
'''
------------------------------------------------------------------------------------------
##########################################################################################
                                    Program Executes Below                                
##########################################################################################
------------------------------------------------------------------------------------------
'''

if __name__ == '__main__':

    print("\nnodes-busy: visualize live system resource usage.\nTrouble seeing the output? Try 'nodes-busy --ascii'\n")
    
    # Made job options a class instead of a function so it wouldn't have to be batted around 
    # like a beach ball
    job_options = Args(sys.argv[1:])

    user      = job_options.user
    group     = job_options.group
    partition = job_options.partition
    
    # Check if valid user
    if user != None:
        p = subprocess.Popen(['getent passwd '+user],stdout=subprocess.PIPE, shell=True)
        out,err = p.communicate()
        if out.decode('utf-8') == '':
            print("\nOops! User not found. Check your options and try again.\n")
            usage(1)
            
    # Check if valid group
    if group != None:
        p = subprocess.Popen(['getent group '+group],stdout=subprocess.PIPE, shell=True)
        out,err = p.communicate()
        if out.decode('utf-8') == '':
            print("\nOops! Group not found. Check your options and try again.\n")
            usage(1)
          
    # Check if valid partition.         
    valid_partitions = get_partitions()
    if partition != None and partition not in valid_partitions:
        print("\nOops! Partition not recognized.\n")
        usage(1)
        
    # If user wants to get random colors, a random seed is set
    if job_options.color_random != False:
        seed = random.randint(1,1000)
    else:
        seed = None

    # Pull job data using "scontrol show jobs --all"
    job_data = get_scontrol_job_data()
    
    # Pull job data using "scontrol show nodes --all"
    node_data = get_scontrol_node_data()
    
    # Merge the two dictionaries above to create one 
    merged = merge(job_data, node_data)

    # Set vis options
    vis = VisOptions(seed,job_options.use_ascii)
    
    # We won't need node_data or job_data again since everything's in merged
    del node_data, job_data
    
    if job_options.node == None:
        display(merged,job_options,vis)
        
    else:
        single_node_display(job_options.node,merged,job_options.use_ascii,vis)

